#!/usr/bin/env python3
"""
Coverage Tracker - Track test coverage during Python 2 to 3 migration

This module helps track test coverage for files being migrated, identify
risky migrations (low coverage), and monitor coverage trends over time.
"""

import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class CoverageTracker:
    """Track and analyze test coverage during migration."""
    
    def __init__(self, project_path: str = "."):
        self.project_path = Path(project_path).resolve()
        self.coverage_dir = self.project_path / ".py2to3" / "coverage"
        self.coverage_dir.mkdir(parents=True, exist_ok=True)
        self.snapshots_file = self.coverage_dir / "snapshots.json"
        
    def run_coverage(self, test_command: Optional[str] = None) -> Tuple[bool, str]:
        """Run tests with coverage collection."""
        if test_command is None:
            # Try common test commands
            test_commands = [
                "pytest --cov=src --cov-report=json",
                "pytest --cov=. --cov-report=json",
                "python -m pytest --cov=src --cov-report=json",
                "python -m coverage run -m pytest",
            ]
        else:
            test_commands = [test_command]
        
        for cmd in test_commands:
            try:
                result = subprocess.run(
                    cmd.split(),
                    capture_output=True,
                    text=True,
                    cwd=self.project_path,
                    timeout=300
                )
                if result.returncode == 0 or os.path.exists(self.project_path / "coverage.json"):
                    return True, f"Coverage collected successfully using: {cmd}"
            except (subprocess.TimeoutExpired, FileNotFoundError):
                continue
        
        return False, "Could not run coverage. Try installing pytest-cov: pip install pytest-cov"
    
    def parse_coverage_json(self) -> Optional[Dict]:
        """Parse coverage.json file generated by pytest-cov."""
        coverage_file = self.project_path / "coverage.json"
        if not coverage_file.exists():
            coverage_file = self.project_path / ".coverage"
            if coverage_file.exists():
                # Try to convert .coverage to JSON
                try:
                    subprocess.run(
                        ["coverage", "json"],
                        cwd=self.project_path,
                        capture_output=True,
                        timeout=30
                    )
                    coverage_file = self.project_path / "coverage.json"
                except:
                    return None
        
        if not coverage_file.exists():
            return None
        
        try:
            with open(coverage_file) as f:
                return json.load(f)
        except:
            return None
    
    def analyze_coverage(self, coverage_data: Dict) -> Dict:
        """Analyze coverage data and extract key metrics."""
        if not coverage_data:
            return {}
        
        files = coverage_data.get("files", {})
        totals = coverage_data.get("totals", {})
        
        analysis = {
            "total_files": len(files),
            "overall_coverage": totals.get("percent_covered", 0),
            "total_statements": totals.get("num_statements", 0),
            "covered_statements": totals.get("covered_lines", 0),
            "missing_statements": totals.get("missing_lines", 0),
            "files": {},
            "low_coverage_files": [],
            "uncovered_files": [],
        }
        
        # Analyze each file
        for filepath, file_data in files.items():
            summary = file_data.get("summary", {})
            coverage_pct = summary.get("percent_covered", 0)
            
            file_analysis = {
                "path": filepath,
                "coverage": coverage_pct,
                "statements": summary.get("num_statements", 0),
                "covered": summary.get("covered_lines", 0),
                "missing": summary.get("missing_lines", 0),
            }
            
            analysis["files"][filepath] = file_analysis
            
            # Categorize files by coverage
            if coverage_pct == 0:
                analysis["uncovered_files"].append(file_analysis)
            elif coverage_pct < 50:
                analysis["low_coverage_files"].append(file_analysis)
        
        # Sort by coverage
        analysis["low_coverage_files"].sort(key=lambda x: x["coverage"])
        
        return analysis
    
    def save_snapshot(self, analysis: Dict, description: str = ""):
        """Save coverage snapshot with timestamp."""
        snapshots = self._load_snapshots()
        
        snapshot = {
            "timestamp": datetime.now().isoformat(),
            "description": description,
            "analysis": analysis
        }
        
        snapshots.append(snapshot)
        
        with open(self.snapshots_file, "w") as f:
            json.dump(snapshots, f, indent=2)
        
        return snapshot
    
    def _load_snapshots(self) -> List[Dict]:
        """Load coverage snapshots."""
        if not self.snapshots_file.exists():
            return []
        
        try:
            with open(self.snapshots_file) as f:
                return json.load(f)
        except:
            return []
    
    def get_latest_snapshot(self) -> Optional[Dict]:
        """Get the most recent coverage snapshot."""
        snapshots = self._load_snapshots()
        return snapshots[-1] if snapshots else None
    
    def get_coverage_trend(self) -> List[Dict]:
        """Get coverage trend over time."""
        snapshots = self._load_snapshots()
        
        trend = []
        for snapshot in snapshots:
            analysis = snapshot.get("analysis", {})
            trend.append({
                "timestamp": snapshot.get("timestamp"),
                "description": snapshot.get("description"),
                "coverage": analysis.get("overall_coverage", 0),
                "files": analysis.get("total_files", 0),
            })
        
        return trend
    
    def identify_risky_migrations(self, migration_state_path: Optional[str] = None) -> List[Dict]:
        """Identify files that were/will be migrated but have low test coverage."""
        latest = self.get_latest_snapshot()
        if not latest:
            return []
        
        analysis = latest.get("analysis", {})
        low_coverage = analysis.get("low_coverage_files", [])
        uncovered = analysis.get("uncovered_files", [])
        
        # If we have migration state, cross-reference
        risky = []
        if migration_state_path:
            try:
                state_file = Path(migration_state_path)
                if state_file.exists():
                    with open(state_file) as f:
                        state = json.load(f)
                    
                    migrated_files = state.get("files", {})
                    
                    for file_info in low_coverage + uncovered:
                        filepath = file_info["path"]
                        if filepath in migrated_files:
                            file_state = migrated_files[filepath]
                            risky.append({
                                **file_info,
                                "migration_status": file_state.get("status"),
                                "migration_date": file_state.get("date"),
                            })
            except:
                pass
        
        if not risky:
            # Return all low/no coverage files as potentially risky
            risky = low_coverage + uncovered
        
        return risky
    
    def generate_report(self, output_path: Optional[str] = None) -> str:
        """Generate a detailed coverage report."""
        latest = self.get_latest_snapshot()
        if not latest:
            return "No coverage data available. Run 'py2to3 coverage collect' first."
        
        analysis = latest["analysis"]
        trend = self.get_coverage_trend()
        
        # Generate text report
        report_lines = [
            "=" * 70,
            "CODE COVERAGE REPORT",
            "=" * 70,
            "",
            f"Snapshot Date: {latest['timestamp']}",
            f"Description: {latest.get('description', 'N/A')}",
            "",
            "OVERALL METRICS",
            "-" * 70,
            f"Overall Coverage: {analysis['overall_coverage']:.2f}%",
            f"Total Files: {analysis['total_files']}",
            f"Total Statements: {analysis['total_statements']}",
            f"Covered Statements: {analysis['covered_statements']}",
            f"Missing Statements: {analysis['missing_statements']}",
            "",
        ]
        
        # Low coverage files
        low_coverage = analysis.get("low_coverage_files", [])
        if low_coverage:
            report_lines.extend([
                "LOW COVERAGE FILES (< 50%)",
                "-" * 70,
            ])
            for file_info in low_coverage[:10]:  # Top 10
                report_lines.append(
                    f"  {file_info['coverage']:5.1f}%  {file_info['path']}"
                )
            if len(low_coverage) > 10:
                report_lines.append(f"  ... and {len(low_coverage) - 10} more")
            report_lines.append("")
        
        # Uncovered files
        uncovered = analysis.get("uncovered_files", [])
        if uncovered:
            report_lines.extend([
                "UNCOVERED FILES (0%)",
                "-" * 70,
            ])
            for file_info in uncovered[:10]:  # Top 10
                report_lines.append(f"  {file_info['path']}")
            if len(uncovered) > 10:
                report_lines.append(f"  ... and {len(uncovered) - 10} more")
            report_lines.append("")
        
        # Coverage trend
        if len(trend) > 1:
            report_lines.extend([
                "COVERAGE TREND",
                "-" * 70,
            ])
            for entry in trend[-5:]:  # Last 5 snapshots
                timestamp = entry["timestamp"][:19]  # Remove milliseconds
                report_lines.append(
                    f"  {timestamp}  {entry['coverage']:5.1f}%  "
                    f"({entry['files']} files)  {entry.get('description', '')}"
                )
            
            # Calculate trend direction
            if len(trend) >= 2:
                recent_coverage = trend[-1]["coverage"]
                previous_coverage = trend[-2]["coverage"]
                change = recent_coverage - previous_coverage
                
                report_lines.append("")
                if change > 0:
                    report_lines.append(f"  ðŸ“ˆ Coverage improved by {change:.2f}%")
                elif change < 0:
                    report_lines.append(f"  ðŸ“‰ Coverage decreased by {abs(change):.2f}%")
                else:
                    report_lines.append("  âž¡ï¸  Coverage unchanged")
            report_lines.append("")
        
        report_lines.extend([
            "=" * 70,
            "",
        ])
        
        report = "\n".join(report_lines)
        
        # Save to file if requested
        if output_path:
            with open(output_path, "w") as f:
                f.write(report)
        
        return report
    
    def clear_snapshots(self):
        """Clear all coverage snapshots."""
        if self.snapshots_file.exists():
            self.snapshots_file.unlink()
        return True


def main():
    """Main entry point for standalone usage."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Track test coverage during Python 2 to 3 migration"
    )
    parser.add_argument(
        "action",
        choices=["collect", "report", "trend", "risky", "clear"],
        help="Action to perform"
    )
    parser.add_argument(
        "--path",
        default=".",
        help="Project path (default: current directory)"
    )
    parser.add_argument(
        "--output",
        help="Output file for report"
    )
    parser.add_argument(
        "--description",
        help="Description for coverage snapshot"
    )
    parser.add_argument(
        "--test-command",
        help="Custom test command to run"
    )
    
    args = parser.parse_args()
    
    tracker = CoverageTracker(args.path)
    
    if args.action == "collect":
        print("Collecting coverage data...")
        success, message = tracker.run_coverage(args.test_command)
        print(message)
        
        if success:
            coverage_data = tracker.parse_coverage_json()
            if coverage_data:
                analysis = tracker.analyze_coverage(coverage_data)
                snapshot = tracker.save_snapshot(
                    analysis,
                    args.description or "Coverage snapshot"
                )
                print(f"\nâœ“ Coverage snapshot saved")
                print(f"  Overall Coverage: {analysis['overall_coverage']:.2f}%")
                print(f"  Files: {analysis['total_files']}")
            else:
                print("âœ— Could not parse coverage data")
        else:
            sys.exit(1)
    
    elif args.action == "report":
        report = tracker.generate_report(args.output)
        print(report)
        if args.output:
            print(f"Report saved to: {args.output}")
    
    elif args.action == "trend":
        trend = tracker.get_coverage_trend()
        if not trend:
            print("No coverage snapshots available")
            sys.exit(1)
        
        print("\nCoverage Trend:")
        print("-" * 70)
        for entry in trend:
            timestamp = entry["timestamp"][:19]
            print(
                f"{timestamp}  {entry['coverage']:5.1f}%  "
                f"({entry['files']} files)  {entry.get('description', '')}"
            )
    
    elif args.action == "risky":
        risky = tracker.identify_risky_migrations()
        if not risky:
            print("âœ“ No risky migrations identified")
        else:
            print(f"\nâš  Found {len(risky)} files with low coverage:")
            print("-" * 70)
            for file_info in risky[:20]:
                print(f"  {file_info['coverage']:5.1f}%  {file_info['path']}")
    
    elif args.action == "clear":
        tracker.clear_snapshots()
        print("âœ“ Coverage snapshots cleared")


if __name__ == "__main__":
    main()
