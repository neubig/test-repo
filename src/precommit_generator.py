#!/usr/bin/env python3
"""
Pre-commit Hook Generator for Python 2 to 3 Migration

This module provides functionality to generate and manage pre-commit hooks that
prevent Python 2 code from being committed during migration. It integrates with
the popular pre-commit framework and provides custom hooks for Python 3 validation.

Features:
- Generate .pre-commit-config.yaml with Python 3 validation
- Create custom hook scripts
- Support for strict, normal, and lenient validation modes
- Easy installation and uninstallation
- Integration with existing py2to3 verifier
"""

import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional


class PreCommitGenerator:
    """Generator for pre-commit hooks that enforce Python 3 compatibility."""
    
    def __init__(self, repo_root: Optional[str] = None):
        """Initialize pre-commit generator.
        
        Args:
            repo_root: Root directory of the repository (default: current directory)
        """
        self.repo_root = Path(repo_root) if repo_root else Path.cwd()
        self.precommit_config = self.repo_root / '.pre-commit-config.yaml'
        self.hooks_dir = self.repo_root / '.git' / 'hooks'
        self.custom_hook_script = self.repo_root / '.git' / 'hooks' / 'py2to3-validator'
    
    def generate_precommit_config(self, mode: str = 'normal', 
                                   files_pattern: str = '\\.py$',
                                   exclude_pattern: str = '') -> str:
        """Generate .pre-commit-config.yaml content.
        
        Args:
            mode: Validation strictness ('strict', 'normal', 'lenient')
            files_pattern: Regex pattern for files to check
            exclude_pattern: Regex pattern for files to exclude
            
        Returns:
            str: YAML configuration content
        """
        # Determine severity threshold based on mode
        severity_map = {
            'strict': 'low',      # Fail on any issues
            'normal': 'medium',   # Fail on medium+ issues  
            'lenient': 'high'     # Fail only on critical issues
        }
        severity = severity_map.get(mode, 'medium')
        
        exclude_line = f"    exclude: '{exclude_pattern}'\n" if exclude_pattern else ""
        
        config = f"""# Pre-commit hooks for Python 2 to 3 migration
# Generated by py2to3 toolkit
# See https://pre-commit.com for more information

repos:
  # Standard Python hooks
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-added-large-files
      - id: check-merge-conflict
      - id: debug-statements

  # Python 3 compatibility check
  - repo: local
    hooks:
      - id: py2to3-validator
        name: Python 3 Compatibility Check
        entry: python .git/hooks/py2to3-validator
        language: system
        types: [python]
        files: '{files_pattern}'
{exclude_line}        pass_filenames: true
        stages: [commit]
        verbose: true

  # Code formatting (optional but recommended)
  - repo: https://github.com/psf/black
    rev: 23.12.1
    hooks:
      - id: black
        language_version: python3
        args: ['--line-length=100']

  # Import sorting (optional but recommended)
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
        args: ['--profile=black', '--line-length=100']

# Configuration
default_language_version:
  python: python3

fail_fast: false
"""
        return config
    
    def generate_validator_script(self, mode: str = 'normal') -> str:
        """Generate the custom validator hook script.
        
        Args:
            mode: Validation strictness ('strict', 'normal', 'lenient')
            
        Returns:
            str: Hook script content
        """
        # Map mode to issues that should fail the hook
        issue_checks = {
            'strict': '''
        # Strict mode - fail on any Python 2 patterns
        if any(issue_type in line.lower() for issue_type in [
            'print', 'import', 'exception', 'unicode', 'basestring',
            'xrange', 'iteritems', 'iterkeys', 'itervalues', 'dict.keys()',
            '__cmp__', 'cmp(', 'execfile', 'reload(', 'apply(',
            'buffer(', 'long(', '.has_key(', 'raw_input(', '<>'
        ]):
            issues.append((filename, line))
''',
            'normal': '''
        # Normal mode - fail on common Python 2 issues
        if any(issue_type in line.lower() for issue_type in [
            'print statement', 'old-style', 'unicode()', 'basestring',
            'xrange(', '.iteritems()', '.iterkeys()', '.itervalues()',
            'except.*,', 'import urllib2', 'import configparser'
        ]):
            issues.append((filename, line))
''',
            'lenient': '''
        # Lenient mode - fail only on critical Python 2 issues
        if any(issue_type in line.lower() for issue_type in [
            'critical', 'syntax error', 'import error', 'modulenotfound'
        ]):
            issues.append((filename, line))
'''
        }
        
        check_code = issue_checks.get(mode, issue_checks['normal'])
        
        script = f'''#!/usr/bin/env python3
"""
Custom pre-commit hook for Python 3 compatibility validation.
Generated by py2to3 toolkit - Mode: {mode}

This hook checks staged Python files for Python 2 compatibility issues.
It runs before each commit to prevent regression during migration.
"""

import os
import re
import sys
import subprocess
from pathlib import Path


def check_python3_compatibility(filenames):
    """Check files for Python 3 compatibility issues.
    
    Args:
        filenames: List of file paths to check
        
    Returns:
        List of (filename, issue) tuples
    """
    issues = []
    
    for filename in filenames:
        if not os.path.exists(filename):
            continue
            
        try:
            with open(filename, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Check for common Python 2 patterns
            lines = content.split('\\n')
            for i, line in enumerate(lines, 1):
{check_code}
                
            # Try to compile with Python 3
            try:
                compile(content, filename, 'exec')
            except SyntaxError as e:
                issues.append((filename, f"Syntax Error at line {{e.lineno}}: {{e.msg}}"))
                
        except Exception as e:
            print(f"Warning: Could not check {{filename}}: {{e}}", file=sys.stderr)
    
    return issues


def check_with_verifier(filenames):
    """Use py2to3 verifier if available.
    
    Args:
        filenames: List of file paths to check
        
    Returns:
        List of issues found
    """
    # Try to find py2to3 command
    py2to3_paths = ['./py2to3', 'py2to3']
    py2to3_cmd = None
    
    for path in py2to3_paths:
        try:
            result = subprocess.run(
                [path, '--version'],
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                py2to3_cmd = path
                break
        except:
            continue
    
    if not py2to3_cmd:
        return []
    
    # Run verifier on files
    issues = []
    for filename in filenames:
        try:
            result = subprocess.run(
                [py2to3_cmd, 'check', filename],
                capture_output=True,
                text=True,
                timeout=30
            )
            if result.returncode != 0 or 'issue' in result.stdout.lower():
                issues.append((filename, "Compatibility issues detected"))
        except:
            pass
    
    return issues


def main():
    """Main entry point for the pre-commit hook."""
    filenames = sys.argv[1:]
    
    if not filenames:
        print("No files to check")
        return 0
    
    print(f"ðŸ” Checking {{len(filenames)}} Python file(s) for Python 3 compatibility...")
    
    # Run basic checks
    issues = check_python3_compatibility(filenames)
    
    # Run verifier if available (more thorough)
    verifier_issues = check_with_verifier(filenames)
    issues.extend(verifier_issues)
    
    if issues:
        print("\\nâŒ Python 2 compatibility issues detected:\\n")
        for filename, issue in issues:
            print(f"  {{filename}}: {{issue}}")
        print("\\nðŸ’¡ Fix these issues before committing, or use 'git commit --no-verify' to bypass.")
        print("   (Not recommended during migration!)\\n")
        return 1
    
    print("âœ… All files are Python 3 compatible!\\n")
    return 0


if __name__ == '__main__':
    sys.exit(main())
'''
        return script
    
    def install_hooks(self, mode: str = 'normal', 
                     files_pattern: str = '\\.py$',
                     exclude_pattern: str = '',
                     force: bool = False) -> Dict[str, bool]:
        """Install pre-commit hooks.
        
        Args:
            mode: Validation strictness ('strict', 'normal', 'lenient')
            files_pattern: Regex pattern for files to check
            exclude_pattern: Regex pattern for files to exclude  
            force: Overwrite existing configuration
            
        Returns:
            Dict with installation status
        """
        results = {
            'config_created': False,
            'hook_created': False,
            'precommit_installed': False,
            'errors': []
        }
        
        # Check if .git directory exists
        if not (self.repo_root / '.git').exists():
            results['errors'].append("Not a git repository")
            return results
        
        # Generate and write .pre-commit-config.yaml
        if self.precommit_config.exists() and not force:
            results['errors'].append(
                ".pre-commit-config.yaml already exists. Use --force to overwrite."
            )
        else:
            config_content = self.generate_precommit_config(
                mode, files_pattern, exclude_pattern
            )
            self.precommit_config.write_text(config_content)
            results['config_created'] = True
        
        # Create hooks directory if it doesn't exist
        self.hooks_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate and write validator script
        script_content = self.generate_validator_script(mode)
        self.custom_hook_script.write_text(script_content)
        self.custom_hook_script.chmod(0o755)  # Make executable
        results['hook_created'] = True
        
        # Try to install pre-commit
        try:
            # Check if pre-commit is installed
            subprocess.run(
                ['pre-commit', '--version'],
                check=True,
                capture_output=True
            )
            
            # Install the hooks
            subprocess.run(
                ['pre-commit', 'install'],
                cwd=self.repo_root,
                check=True,
                capture_output=True
            )
            results['precommit_installed'] = True
        except (subprocess.CalledProcessError, FileNotFoundError):
            results['errors'].append(
                "pre-commit is not installed. Install it with: pip install pre-commit"
            )
        
        return results
    
    def uninstall_hooks(self) -> Dict[str, bool]:
        """Uninstall pre-commit hooks.
        
        Returns:
            Dict with uninstallation status
        """
        results = {
            'config_removed': False,
            'hook_removed': False,
            'precommit_uninstalled': False,
            'errors': []
        }
        
        # Remove .pre-commit-config.yaml
        if self.precommit_config.exists():
            self.precommit_config.unlink()
            results['config_removed'] = True
        
        # Remove custom hook script
        if self.custom_hook_script.exists():
            self.custom_hook_script.unlink()
            results['hook_removed'] = True
        
        # Uninstall pre-commit
        try:
            subprocess.run(
                ['pre-commit', 'uninstall'],
                cwd=self.repo_root,
                capture_output=True
            )
            results['precommit_uninstalled'] = True
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass
        
        return results
    
    def check_status(self) -> Dict[str, any]:
        """Check installation status of pre-commit hooks.
        
        Returns:
            Dict with status information
        """
        status = {
            'config_exists': self.precommit_config.exists(),
            'hook_exists': self.custom_hook_script.exists(),
            'precommit_available': False,
            'precommit_installed': False,
            'git_repo': (self.repo_root / '.git').exists()
        }
        
        # Check if pre-commit is available
        try:
            result = subprocess.run(
                ['pre-commit', '--version'],
                capture_output=True
            )
            status['precommit_available'] = result.returncode == 0
            if status['precommit_available']:
                status['precommit_version'] = result.stdout.decode().strip()
        except FileNotFoundError:
            pass
        
        # Check if pre-commit is installed in repo
        pre_commit_hook = self.hooks_dir / 'pre-commit'
        if pre_commit_hook.exists():
            content = pre_commit_hook.read_text()
            status['precommit_installed'] = 'pre-commit' in content
        
        # Read current mode from config if it exists
        if status['config_exists']:
            config_content = self.precommit_config.read_text()
            if 'py2to3-validator' in config_content:
                status['mode'] = 'configured'
        
        return status
    
    def test_hooks(self, test_file: Optional[str] = None) -> Dict[str, any]:
        """Test pre-commit hooks without committing.
        
        Args:
            test_file: Optional file to test (default: all staged files)
            
        Returns:
            Dict with test results
        """
        results = {
            'success': False,
            'output': '',
            'errors': []
        }
        
        try:
            cmd = ['pre-commit', 'run']
            if test_file:
                cmd.extend(['--files', test_file])
            else:
                cmd.append('--all-files')
            
            result = subprocess.run(
                cmd,
                cwd=self.repo_root,
                capture_output=True,
                text=True
            )
            
            results['output'] = result.stdout + result.stderr
            results['success'] = result.returncode == 0
            
        except FileNotFoundError:
            results['errors'].append("pre-commit is not installed")
        except Exception as e:
            results['errors'].append(str(e))
        
        return results


def main():
    """CLI entry point for standalone usage."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Generate pre-commit hooks for Python 3 migration'
    )
    parser.add_argument(
        'action',
        choices=['install', 'uninstall', 'status', 'test'],
        help='Action to perform'
    )
    parser.add_argument(
        '--mode',
        choices=['strict', 'normal', 'lenient'],
        default='normal',
        help='Validation strictness level'
    )
    parser.add_argument(
        '--files-pattern',
        default='\\.py$',
        help='Regex pattern for files to check'
    )
    parser.add_argument(
        '--exclude-pattern',
        default='',
        help='Regex pattern for files to exclude'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force overwrite of existing configuration'
    )
    parser.add_argument(
        '--test-file',
        help='Specific file to test'
    )
    
    args = parser.parse_args()
    
    generator = PreCommitGenerator()
    
    if args.action == 'install':
        results = generator.install_hooks(
            mode=args.mode,
            files_pattern=args.files_pattern,
            exclude_pattern=args.exclude_pattern,
            force=args.force
        )
        print("Installation Results:")
        for key, value in results.items():
            print(f"  {key}: {value}")
    
    elif args.action == 'uninstall':
        results = generator.uninstall_hooks()
        print("Uninstallation Results:")
        for key, value in results.items():
            print(f"  {key}: {value}")
    
    elif args.action == 'status':
        status = generator.check_status()
        print("Pre-commit Hook Status:")
        for key, value in status.items():
            print(f"  {key}: {value}")
    
    elif args.action == 'test':
        results = generator.test_hooks(args.test_file)
        print("Test Results:")
        print(results['output'])
        if results['errors']:
            print("Errors:")
            for error in results['errors']:
                print(f"  - {error}")
        sys.exit(0 if results['success'] else 1)


if __name__ == '__main__':
    main()
