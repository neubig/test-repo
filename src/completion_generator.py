#!/usr/bin/env python3
"""
Shell Completion Generator for py2to3 CLI

Generates shell completion scripts for bash, zsh, and fish to improve
developer experience with the comprehensive py2to3 command-line interface.
"""

import os
import sys
from pathlib import Path
from typing import List, Dict, Optional


class CompletionGenerator:
    """Generate shell completion scripts for py2to3 CLI."""

    # All available commands in py2to3
    COMMANDS = [
        'check', 'fix', 'preflight', 'backup', 'compare', 'stats',
        'interactive', 'report', 'migrate', 'recipe', 'state', 'journal',
        'config', 'git', 'deps', 'test-gen', 'risk', 'plan', 'quality',
        'bench', 'watch', 'dashboard', 'health', 'lint', 'docs', 'status',
        'search', 'venv', 'imports', 'modernize', 'convert', 'version-check',
        'review', 'typehints', 'estimate', 'export', 'import', 'rollback',
        'freeze', 'validate', 'encoding', 'report-card', 'metadata',
        'changelog', 'wizard', 'precommit', 'completion'
    ]

    # Common options available across commands
    GLOBAL_OPTIONS = [
        '--help', '-h', '--version', '-v', '--verbose', '--quiet',
        '--no-color', '--config'
    ]

    # Command-specific options and subcommands
    COMMAND_OPTIONS = {
        'check': ['--report', '--json', '--verbose'],
        'fix': ['--backup-dir', '--report', '--dry-run', '--pattern'],
        'preflight': ['--json', '--fix', '--detailed'],
        'backup': ['list', 'restore', 'clean', 'diff', 'scan', '--path', '--backup-id', '--output'],
        'compare': ['--output', '--format'],
        'stats': ['collect', 'show', 'history', 'clear', '--save', '--format', '--output'],
        'config': ['init', 'show', 'get', 'set', 'list', '--global', '--local'],
        'git': ['status', 'info', 'branch', 'checkpoint', 'commit', 'log', 'rollback', 'diff'],
        'recipe': ['list', 'show', 'apply', 'create', 'delete', '--name', '--tags'],
        'state': ['init', 'show', 'update', 'rollback', 'history', 'clean'],
        'journal': ['init', 'add', 'list', 'show', 'search', 'export', 'stats'],
        'test-gen': ['--output', '--pattern', '--coverage'],
        'venv': ['create', 'activate', 'install', 'test', 'freeze', '--name', '--python'],
        'export': ['create', 'list', 'info', '--output', '--compression'],
        'import': ['--dry-run', '--overwrite'],
        'rollback': ['--operation-id', '--preview', '--force'],
        'modernize': ['--target-version', '--aggressive'],
        'convert': ['--format', '--output'],
        'typehints': ['--aggressive', '--safe'],
        'estimate': ['--detailed', '--format'],
        'precommit': ['install', 'uninstall', 'status', 'test', '--mode'],
        'completion': ['generate', 'install', 'uninstall', 'status', 'bash', 'zsh', 'fish'],
    }

    def generate_bash_completion(self) -> str:
        """Generate bash completion script."""
        commands = ' '.join(self.COMMANDS)
        
        script = f'''# bash completion for py2to3
# Generated by py2to3 completion generator

_py2to3_completions()
{{
    local cur prev opts base
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"
    
    # Main commands
    commands="{commands}"
    
    # Global options
    global_opts="--help -h --version -v --verbose --quiet --no-color --config"
    
    # If we're completing the first argument (command)
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "$commands $global_opts" -- ${{cur}}) )
        return 0
    fi
    
    # Get the main command
    local command="${{COMP_WORDS[1]}}"
    
    # Command-specific completions
    case "$command" in
        backup)
            local backup_opts="list restore clean diff scan --path --backup-id --output"
            COMPREPLY=( $(compgen -W "$backup_opts" -- ${{cur}}) )
            ;;
        stats)
            local stats_opts="collect show history clear --save --format --output"
            COMPREPLY=( $(compgen -W "$stats_opts" -- ${{cur}}) )
            ;;
        config)
            local config_opts="init show get set list --global --local"
            COMPREPLY=( $(compgen -W "$config_opts" -- ${{cur}}) )
            ;;
        git)
            local git_opts="status info branch checkpoint commit log rollback diff"
            COMPREPLY=( $(compgen -W "$git_opts" -- ${{cur}}) )
            ;;
        recipe)
            local recipe_opts="list show apply create delete --name --tags"
            COMPREPLY=( $(compgen -W "$recipe_opts" -- ${{cur}}) )
            ;;
        state)
            local state_opts="init show update rollback history clean"
            COMPREPLY=( $(compgen -W "$state_opts" -- ${{cur}}) )
            ;;
        journal)
            local journal_opts="init add list show search export stats"
            COMPREPLY=( $(compgen -W "$journal_opts" -- ${{cur}}) )
            ;;
        venv)
            local venv_opts="create activate install test freeze --name --python"
            COMPREPLY=( $(compgen -W "$venv_opts" -- ${{cur}}) )
            ;;
        export)
            local export_opts="create list info --output --compression"
            COMPREPLY=( $(compgen -W "$export_opts" -- ${{cur}}) )
            ;;
        precommit)
            local precommit_opts="install uninstall status test --mode"
            COMPREPLY=( $(compgen -W "$precommit_opts" -- ${{cur}}) )
            ;;
        completion)
            local completion_opts="generate install uninstall status bash zsh fish"
            COMPREPLY=( $(compgen -W "$completion_opts" -- ${{cur}}) )
            ;;
        check)
            local check_opts="--report --json --verbose"
            COMPREPLY=( $(compgen -W "$check_opts" -- ${{cur}}) )
            ;;
        fix)
            local fix_opts="--backup-dir --report --dry-run --pattern"
            COMPREPLY=( $(compgen -W "$fix_opts" -- ${{cur}}) )
            ;;
        *)
            COMPREPLY=( $(compgen -W "$global_opts" -- ${{cur}}) )
            ;;
    esac
    
    # File/directory completion for certain options
    if [[ "$prev" == "--config" || "$prev" == "--output" || "$prev" == "--report" ]]; then
        COMPREPLY=( $(compgen -f -- ${{cur}}) )
    fi
}}

complete -F _py2to3_completions py2to3
complete -F _py2to3_completions ./py2to3
'''
        return script

    def generate_zsh_completion(self) -> str:
        """Generate zsh completion script."""
        commands_list = '\n        '.join([f'"{cmd}:Run {cmd} command"' for cmd in self.COMMANDS])
        
        script = f'''#compdef py2to3
# zsh completion for py2to3
# Generated by py2to3 completion generator

_py2to3() {{
    local line state

    _arguments -C \\
        "1: :((${{_py2to3_commands}}))" \\
        '*::arg:->args'

    case $line[1] in
        backup)
            _py2to3_backup
            ;;
        stats)
            _py2to3_stats
            ;;
        config)
            _py2to3_config
            ;;
        git)
            _py2to3_git
            ;;
        completion)
            _py2to3_completion
            ;;
    esac
}}

_py2to3_commands=(
    {commands_list}
)

_py2to3_backup() {{
    _arguments \\
        '1: :(list restore clean diff scan)' \\
        '--path[Path to backup]:filename:_files' \\
        '--backup-id[Backup ID]:' \\
        '--output[Output file]:filename:_files'
}}

_py2to3_stats() {{
    _arguments \\
        '1: :(collect show history clear)' \\
        '--save[Save statistics]' \\
        '--format[Output format]:(json text table)' \\
        '--output[Output file]:filename:_files'
}}

_py2to3_config() {{
    _arguments \\
        '1: :(init show get set list)' \\
        '--global[Use global config]' \\
        '--local[Use local config]'
}}

_py2to3_git() {{
    _arguments \\
        '1: :(status info branch checkpoint commit log rollback diff)'
}}

_py2to3_completion() {{
    _arguments \\
        '1: :(generate install uninstall status)' \\
        '2: :(bash zsh fish)'
}}

_py2to3
'''
        return script

    def generate_fish_completion(self) -> str:
        """Generate fish completion script."""
        commands_completions = '\n'.join([
            f"complete -c py2to3 -n '__fish_use_subcommand' -a '{cmd}' -d '{cmd.capitalize()} command'"
            for cmd in self.COMMANDS
        ])
        
        script = f'''# fish completion for py2to3
# Generated by py2to3 completion generator

# Remove any existing completions
complete -c py2to3 -e

# Global options
complete -c py2to3 -l help -s h -d 'Show help message'
complete -c py2to3 -l version -s v -d 'Show version'
complete -c py2to3 -l verbose -d 'Verbose output'
complete -c py2to3 -l quiet -d 'Quiet output'
complete -c py2to3 -l no-color -d 'Disable colored output'
complete -c py2to3 -l config -d 'Configuration file' -r

# Main commands
{commands_completions}

# Backup subcommands
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -a 'list' -d 'List backups'
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -a 'restore' -d 'Restore backup'
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -a 'clean' -d 'Clean old backups'
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -a 'diff' -d 'Show differences'
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -a 'scan' -d 'Scan backups'
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -l path -d 'Path to backup' -r
complete -c py2to3 -n '__fish_seen_subcommand_from backup' -l backup-id -d 'Backup ID'

# Stats subcommands
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -a 'collect' -d 'Collect statistics'
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -a 'show' -d 'Show statistics'
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -a 'history' -d 'Show history'
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -a 'clear' -d 'Clear statistics'
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -l save -d 'Save statistics'
complete -c py2to3 -n '__fish_seen_subcommand_from stats' -l format -d 'Output format' -a 'json text table'

# Config subcommands
complete -c py2to3 -n '__fish_seen_subcommand_from config' -a 'init' -d 'Initialize config'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -a 'show' -d 'Show config'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -a 'get' -d 'Get config value'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -a 'set' -d 'Set config value'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -a 'list' -d 'List config keys'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -l global -d 'Use global config'
complete -c py2to3 -n '__fish_seen_subcommand_from config' -l local -d 'Use local config'

# Git subcommands
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'status' -d 'Show git status'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'info' -d 'Show git info'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'branch' -d 'Create branch'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'checkpoint' -d 'Create checkpoint'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'commit' -d 'Commit changes'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'log' -d 'Show git log'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'rollback' -d 'Rollback changes'
complete -c py2to3 -n '__fish_seen_subcommand_from git' -a 'diff' -d 'Show differences'

# Completion subcommands
complete -c py2to3 -n '__fish_seen_subcommand_from completion' -a 'generate' -d 'Generate completion script'
complete -c py2to3 -n '__fish_seen_subcommand_from completion' -a 'install' -d 'Install completions'
complete -c py2to3 -n '__fish_seen_subcommand_from completion' -a 'uninstall' -d 'Uninstall completions'
complete -c py2to3 -n '__fish_seen_subcommand_from completion' -a 'status' -d 'Show completion status'
complete -c py2to3 -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate' -a 'bash zsh fish' -d 'Shell type'

# Check command options
complete -c py2to3 -n '__fish_seen_subcommand_from check' -l report -d 'Report file' -r
complete -c py2to3 -n '__fish_seen_subcommand_from check' -l json -d 'JSON output'
complete -c py2to3 -n '__fish_seen_subcommand_from check' -l verbose -d 'Verbose output'

# Fix command options
complete -c py2to3 -n '__fish_seen_subcommand_from fix' -l backup-dir -d 'Backup directory' -r
complete -c py2to3 -n '__fish_seen_subcommand_from fix' -l report -d 'Report file' -r
complete -c py2to3 -n '__fish_seen_subcommand_from fix' -l dry-run -d 'Dry run mode'
complete -c py2to3 -n '__fish_seen_subcommand_from fix' -l pattern -d 'File pattern'
'''
        return script

    def get_shell_config_file(self, shell: str) -> Optional[Path]:
        """Get the configuration file path for the given shell."""
        home = Path.home()
        
        shell_configs = {
            'bash': [
                home / '.bashrc',
                home / '.bash_profile',
                home / '.profile'
            ],
            'zsh': [
                home / '.zshrc',
                home / '.zprofile'
            ],
            'fish': [
                home / '.config' / 'fish' / 'config.fish',
                home / '.config' / 'fish' / 'completions' / 'py2to3.fish'
            ]
        }
        
        configs = shell_configs.get(shell, [])
        
        # Return the first existing config file, or the primary one if none exist
        for config in configs:
            if config.exists():
                return config
        
        return configs[0] if configs else None

    def install_completion(self, shell: str) -> tuple[bool, str]:
        """Install completion for the specified shell."""
        if shell not in ['bash', 'zsh', 'fish']:
            return False, f"Unsupported shell: {shell}"
        
        # Generate the completion script
        if shell == 'bash':
            script = self.generate_bash_completion()
            completion_dir = Path.home() / '.bash_completion.d'
            completion_file = completion_dir / 'py2to3'
        elif shell == 'zsh':
            script = self.generate_zsh_completion()
            completion_dir = Path.home() / '.zsh' / 'completion'
            completion_file = completion_dir / '_py2to3'
        else:  # fish
            script = self.generate_fish_completion()
            completion_dir = Path.home() / '.config' / 'fish' / 'completions'
            completion_file = completion_dir / 'py2to3.fish'
        
        # Create completion directory if it doesn't exist
        try:
            completion_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            return False, f"Failed to create completion directory: {e}"
        
        # Write the completion script
        try:
            with open(completion_file, 'w') as f:
                f.write(script)
        except Exception as e:
            return False, f"Failed to write completion script: {e}"
        
        # Additional setup for bash and zsh
        if shell in ['bash', 'zsh']:
            config_file = self.get_shell_config_file(shell)
            if config_file:
                source_line = f"source {completion_file}"
                
                # Check if already sourced
                try:
                    if config_file.exists():
                        with open(config_file, 'r') as f:
                            content = f.read()
                            if source_line in content or str(completion_file) in content:
                                return True, f"Completion installed to {completion_file}"
                    
                    # Add source line to config
                    with open(config_file, 'a') as f:
                        f.write(f"\n# py2to3 completion\n{source_line}\n")
                    
                    return True, f"Completion installed to {completion_file}\\nAdded source line to {config_file}\\nRestart your shell or run: source {config_file}"
                except Exception as e:
                    return True, f"Completion script created at {completion_file}\\nPlease manually add this line to your {config_file}:\\n  {source_line}"
        
        return True, f"Completion installed to {completion_file}\\nRestart your shell to activate completions"

    def uninstall_completion(self, shell: str) -> tuple[bool, str]:
        """Uninstall completion for the specified shell."""
        if shell not in ['bash', 'zsh', 'fish']:
            return False, f"Unsupported shell: {shell}"
        
        # Determine completion file location
        if shell == 'bash':
            completion_file = Path.home() / '.bash_completion.d' / 'py2to3'
        elif shell == 'zsh':
            completion_file = Path.home() / '.zsh' / 'completion' / '_py2to3'
        else:  # fish
            completion_file = Path.home() / '.config' / 'fish' / 'completions' / 'py2to3.fish'
        
        # Remove completion file
        removed = False
        if completion_file.exists():
            try:
                completion_file.unlink()
                removed = True
            except Exception as e:
                return False, f"Failed to remove completion file: {e}"
        
        # Clean up shell config file
        if shell in ['bash', 'zsh']:
            config_file = self.get_shell_config_file(shell)
            if config_file and config_file.exists():
                try:
                    with open(config_file, 'r') as f:
                        lines = f.readlines()
                    
                    # Remove py2to3 completion lines
                    new_lines = []
                    skip_next = False
                    for line in lines:
                        if '# py2to3 completion' in line:
                            skip_next = True
                            continue
                        if skip_next and 'py2to3' in line and 'source' in line:
                            skip_next = False
                            continue
                        new_lines.append(line)
                    
                    with open(config_file, 'w') as f:
                        f.writelines(new_lines)
                except Exception as e:
                    pass  # Not critical if we can't clean up config
        
        if removed:
            return True, f"Completion uninstalled from {completion_file}\\nRestart your shell to apply changes"
        else:
            return False, "No completion installation found"

    def check_completion_status(self) -> Dict[str, bool]:
        """Check which shell completions are installed."""
        status = {}
        
        bash_completion = Path.home() / '.bash_completion.d' / 'py2to3'
        status['bash'] = bash_completion.exists()
        
        zsh_completion = Path.home() / '.zsh' / 'completion' / '_py2to3'
        status['zsh'] = zsh_completion.exists()
        
        fish_completion = Path.home() / '.config' / 'fish' / 'completions' / 'py2to3.fish'
        status['fish'] = fish_completion.exists()
        
        return status

    def detect_shell(self) -> Optional[str]:
        """Detect the current shell."""
        shell = os.environ.get('SHELL', '')
        
        if 'bash' in shell:
            return 'bash'
        elif 'zsh' in shell:
            return 'zsh'
        elif 'fish' in shell:
            return 'fish'
        
        return None


if __name__ == '__main__':
    # Simple CLI for testing
    import sys
    
    generator = CompletionGenerator()
    
    if len(sys.argv) > 1:
        shell = sys.argv[1]
        if shell == 'bash':
            print(generator.generate_bash_completion())
        elif shell == 'zsh':
            print(generator.generate_zsh_completion())
        elif shell == 'fish':
            print(generator.generate_fish_completion())
        else:
            print(f"Unknown shell: {shell}", file=sys.stderr)
            sys.exit(1)
    else:
        print("Usage: completion_generator.py [bash|zsh|fish]")
        sys.exit(1)
